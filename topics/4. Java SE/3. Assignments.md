# **PROJECT ASSIGNMENTS: STUDENT MANAGEMENT SYSTEM**

Context:  
You are building a backend system to manage Students in a University. The system will start as a Console Application and evolve to use Database and File I/O.

## **ASSIGNMENT 01: PROJECT BOOTSTRAP & CORE DOMAIN**

_(For Session 3)_

**Objective:** Apply Maven, OOP, and Clean Code to setup the project structure.

**Deliverables:**

- Maven Project with correct structure.
- Basic Console UI (Menu based).
- Domain Models.

**Requirements:**

1. **Maven Setup:**
   - Create a clean connection Maven project.
   - `pom.xml` should have compiler properties set to Java 17+.

2. **Layered Architecture:**
   - Organize packages:
     - `com.university.model` (Entities)
     - `com.university.service` (Business Logic)
     - `com.university.repository` (Data Access - In-memory for now)
     - `com.university.app` (Main/Console UI)

3. **Feature - Student Management (Simple):**
   - Create class `Student` (id, name, email, gpa).
   - Implement `addStudent` and `listStudents` in Service/Repository.
   - **Validation:** ID must be unique. GPA must be 0-10.
   - **Console:** Show a menu: 1. Add, 2. List, 3. Exit.

> **Critical Thinking:**
>
> - **Architecture:** Why do we separate `Service` (Business Logic) from `Repository` (Data Access)? What happens if we mix them?

- **Encapsulation:** Should we return the internal `List<Student>` directly from `Repository.getAll()`? Why is returning a defensive copy (e.g. `new ArrayList<>(internalList)`) or an Unmodifiable List better?
- **Access Modifiers:** Why should the `Student` class fields be `private`? What if they were `public`?
- **Immutability:** If `Student` was an immutable class (all `final` fields, no setters), how would that change our update logic? What are the benefits for concurrency?

---

## **ASSIGNMENT 02: COLLECTIONS & FUNCTIONAL ENHANCEMENTS**

_(For Session 5)_

**Objective:** Refactor the application to use robust Collections, Streams, and handle Errors.

**Requirements:**

1. **Collections Upgrade:**
   - Use `HashMap<String, Student>` in Repository with ID as Key for O(1) access.
   - Ensure `Student` overrides `equals/hashCode` correctly using ID.

2. **Functional Logic (Streams):**
   - Implement `searchStudents(String name)` using Stream `.filter()`.
   - Implement `getTopStudents(int n)` (highest GPA) using Stream `.sorted()`.
   - Implement `getAverageGPA()` using Stream `.mapToDouble()`.

3. **Exception Handling:**
   - Create custom exception `InvalidStudentDataException`.
   - Throw this exception if validation fails (e.g. invalid email format, GPA < 0).
   - Catch it in the UI/Main and show a red/error message to user without crashing.

> **Critical Thinking:**
>
> - **Streams vs Loops:** When filtering students, why might a Stream be slower than a simple for-loop for very small lists? Use Big-O and overhead concept to explain.

- **Exceptions:** Why use a Custom Checked Exception (`InvalidStudentDataException`) instead of `IllegalArgumentException` (Unchecked)? What is the architectural impact on the caller?
- **HashMap Internals:** If we use `HashMap`, what happens if two different students have the same ID (Collision)? How does `hashCode()` affect performance?
- **Null Safety:** How would using `Optional<Student>` return type for `searchById()` change the client code? Is it better than returning `null`?

---

## **ASSIGNMENT 03: DATABASE INTEGRATION**

_(For Session 7b)_

**Objective:** Persist data to a database using JDBC.

**Requirements:**

1. **Database Setup:**
   - Design a table `students` (id VARCHAR PK, name, email, gpa).
   - Add Database Driver dependency (e.g., MySQL/PostgreSQL/H2) to `pom.xml`.

2. **JDBC Repository:**
   - Create `JdbcStudentRepository` implementing the same interface as your Memory repository.
   - Implement `save`, `findAll`, `delete`.
   - **Must Use:** `PreparedStatement` to prevent SQL Injection.
   - **Must Use:** `try-with-resources` to close connections.

3. **Transaction (Bonus):**
   - Simulate a "Bulk Import": Start transaction -> Insert 5 students -> If one fails, Rollback all.

> **Critical Thinking:**
>
> - **Refactoring:** How does the Service layer change now that we switched to Database? (Hint: It shouldn't change much if we used Dependency Injection / Interfaces correctly).

- **Performance:** What is the "N+1 Select Problem"? If we had a list of `Classes` and needed to load students for each class, how would a naive JDBC loop cause performance issues?
- **Connection Management:** Why is opening a new `Connection` for every query slow? How would a **Connection Pool** solve this?
- **SQL Injection:** If we used `Statement` instead of `PreparedStatement`, how could a user invoke `deleteStudent` by sending a malicious name in `searchStudent`?

---

## **ASSIGNMENT 04: FILE I/O & CONCURRENCY**

_(For Session 9)_

**Objective:** Add data portability and performance testing.

**Requirements:**

1. **Export/Import Feature:**
   - **Export:** Write all students to `students_export.csv` (CSV format).
   - **Import:** Read from a CSV file and batch insert into system.
   - Use `java.nio.file.Files` API.

2. **Performance Test (Concurrency):**
   - Create a feature to simulate "Heavy Load".
   - Create a method to generate random 10.000 student data.
   - Spawn 5 threads. Each thread tries to add 2.000 random students to the system simultaneously.
   - Observe issues (Race Conditions / ID conflicts) if any.
   - Ensure your ID generation or List addition is thread-safe (e.g., using `Collections.synchronizedMap` or Database locks).

> **Critical Thinking:**
>
> - **Error Handling:** In the CSV Import, if 1 line in 10,000 is corrupted, should we abort the whole transaction or skip/log that line? What are the business implications of each?

- **Concurrency:** If we use `Collections.synchronizedList`, is it fully thread-safe? What happens if we iterate over it while another thread attempts to add?
- **Context Switching:** Why might spawning 100 threads be slower than using a Thread Pool of size 5? Explain Context Switching overhead.
- **File Locks:** What happens if two processes try to write to `students_export.csv` at the exact same time? How does the OS handle file locking?
