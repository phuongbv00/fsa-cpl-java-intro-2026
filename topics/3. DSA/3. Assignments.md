# **PROJECT ASSIGNMENTS: ALGORITHMS & PROBLEM SOLVING**

Context:  
You are building the core utility library for a high-performance system. Efficiency and correctness are paramount. You may use any core language (Java, C#, Python, C++, JS...) but **avoid high-level helper methods that trivialize the implementation logic**.

## **ASSIGNMENT 01: LINEAR DATA STRUCTURES & ALGORITHMS**

_(For Session 2)_

Duration: 4 hours  
Objectives: Implement custom Data Structures and solve classic algorithmic problems.

**Deliverables:**

- Source code for DS classes.
- Solution files for problems (with Big-O analysis).
- Answers to Critical Thinking questions.

### **Part 1: Implement Core Data Structures**

**Requirement:** Do not use Standard Library collections (like `ArrayList`/`LinkedList` in Java, `List` in Python, `vector` in C++) for the internal storage logic. You must build the class wrapping a primitive array or node structure.

1.  **MyDynamicArray:**
    - Implement a dynamic array that resizes (e.g., doubles capacity) when full.
    - Methods: `add(val)`, `get(index)`, `remove(index)`, `size()`.
2.  **MySingleLinkedList:**
    - Implement a Singly Linked List using a Node class/struct.
    - Methods: `addFirst(val)`, `addLast(val)`, `removeFirst()`, `contains(val)`.

> **Critical Thinking:**
>
> - Why does the Dynamic Array resize by doubling (2x) the capacity instead of adding a fixed amount (e.g., +10 elements)? How does this affect Amortized Complexity?
> - Compare the Memory Overhead between a Linked List node (data + pointer) and an Array element. Which one is more cache-friendly?

### **Part 2: Algorithmic Problems**

**Requirement:** Solve the following standard LeetCode-style problems. Focus on Time Complexity.

1.  **Reverse String:**
    - Input: `['h','e','l','l','o']` (or equivalent char array/list) -> Output: `['o','l','l','e','h']`.
    - Constraint: O(1) Extra Space (In-place modification).
2.  **Valid Parentheses:**
    - Input: `"()[]{}"` -> True. Input: `"(]"` -> False.
    - Logic: Use a Stack (Standard Library Stack is allowed) to solve.
3.  **Big-O Analysis:**
    - For each solution above, write a comment explaining why your solution is optimal.

> **Critical Thinking:**
>
> - Why is a **Stack** (LIFO) the perfect structure for the "Valid Parentheses" problem? Could a Queue work?
> - In the Reverse String problem, what are the trade-offs of modifying the array **in-place** vs creating a new string (Mutability vs Immutability)?

## **ASSIGNMENT 02: NON-LINEAR DATA STRUCTURES & OPTIMIZATION**

_(For Session 4)_

Duration: 4 hours  
Objectives: Utilize HashMaps, Trees, and Heaps to solve complex optimization problems.

**Deliverables:**

- Code for HashMap/Heap problems.
- Mini-Case Implementation.
- Answers to Critical Thinking questions.

### **Part 1: HashMap Applications**

1.  **Word Frequency Check:**
    - Input: A long string of text.
    - Output: A Map/Dictionary of `{ word: count }`.
2.  **Deduplication:**
    - Input: An array with huge number of duplicates.
    - Output: A List/Array of unique elements.
    - Requirement: Use a Set data structure.

> **Critical Thinking:**
>
> - We can count word frequency using Nested Loops in O(N^2). Why is the HashMap/Dictionary approach O(N)? What allows looking up a key to be O(1)?
> - What happens if the Hash Function is poor and maps all keys to the same index?

### **Part 2: Heap & Tree Applications**

1.  **Top K Frequent Elements:**
    - Input: An array of numbers (e.g., `[1,1,1,2,2,3]`) and integer `k=2`.
    - Output: The `k` most frequent elements (e.g., `[1, 2]`).
    - **Challenge:** Use a Min-Heap or Max-Heap (Priority Queue) to optimize finding Top K.

> **Critical Thinking:**
>
> - To find Top K, we could Sort the entire array ($N \log N$). Why is using a Heap of size K ($N \log K$) generally better for massive datasets?

### **Part 3: Mini Case Study**

**Requirement:** Choose ONE of the following to implement (Simple Class design). You can use Standard Library Maps/Lists for existing components.

- **Option A: Rate Limiter**
  - Design a `isAllowed(userId)` method.
  - Rule: User can strictly make max 5 requests per minute.
- **Option B: Simple LRU Cache**
  - Design a Cache with fixed capacity.
  - When full, remove the Least Recently Used item.

> **Critical Thinking:**
>
> - **LRU Cache:** Why do we typically need BOTH a HashMap and a Doubly Linked List? What specific role does each DS play to keep operations O(1)?
> - **Rate Limiter:** If we just use a simple counter, what edge case happens at the boundary of a minute (e.g., 00:59 and 01:00)?
