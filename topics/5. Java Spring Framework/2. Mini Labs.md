# **MINI LABS: QUICK PRACTICE EXERCISES**

Purpose: Small, isolated labs to help you verify the theories learned in the Instruction file.  
Requirement: Save screenshot or code snippet for your daily report.

---

### **SESSION 1 LABS: SPRING CORE**

**Lab 1.1 (The Power of DI):**

- **Task:** Create a class `Car` that depends on `Engine`.
- **Without Spring:** Manually create `new Engine()` inside `Car`. Try to swap it with `ElectricEngine` (hard?).
- **With Spring:** Use `@Component` and `@Autowired`. Inject `Engine` interface.
- **Action:** Create two implementations: `V8Engine` and `ElectricEngine`. Use `@Primary` or `@Qualifier` to switch between them without changing `Car` code.

**Lab 1.2 (Bean Scopes):**

- **Task:** Create a Bean `CounterService` with a generic count field.
- **Experiment:**
  1. Default Scope (Singleton): Inject it into two different Controllers. Increment count in one. Check other.
  2. Prototype Scope: Change scope to `@Scope("prototype")`. Repeat.
- **Observation:** Verify when a new instance is created.

---

### **SESSION 3 LABS: WEB MVC**

**Lab 3.1 (Hello REST):**

- **Task:** Create a `@RestController` at `/api/hello`.
- **Action:**
  1. Return a simple String "Hello World".
  2. Return a JSON Object (e.g., `Map<String, String>`).
- **Verify:** Open Browser or Postman/Curl to see the JSON response.

**Lab 3.2 (Inputs):**

- **Task:** Create an endpoint `/api/calculate`.
- **Action:**
  1. Use `@RequestParam` to take `a` and `b`. Return sum. (`/api/calculate?a=5&b=10`).
  2. Create endpoint `/api/users/{id}` using `@PathVariable`. Return "User ID: {id}".
- **Experiment:** meaningful input validation (what if `a` is not a number?).

**Lab 3.3 (API Tools Basics):**

- **Task:** Test previous endpoints without Browser.
- **Action:**
  1. **Postman:** Create a Collection. Add request to `/api/hello`. Save response example.
  2. **cURL:** Use terminal to hit the endpoint: `curl -v http://localhost:8080/api/hello`.
  3. **Practice:** Send a POST request with JSON body using cURL.

---

### **SESSION 4 LABS: SPRING DATA JPA**

**Lab 4.1 (Entity Mapping):**

- **Task:** Create an Entity `Product` (id, name, price).
- **Action:** Run the app. Check Console logs (ensure `spring.jpa.hibernate.ddl-auto=update`).
- **Verify:** See the `CREATE TABLE` SQL statement generated by Hibernate.

**Lab 4.2 (Derived Queries):**

- **Task:** Create `ProductRepository`.
- **Action:** Write method `List<Product> findByNameContaining(String keyword);`
- **Experiment:** Insert 3 products. Call the method from a CommandLineRunner. Print results.

**Lab 4.3 (Transaction Rollback):**

- **Task:** Create a Service method `createTwoProducts()`.
- **Action:**
  1. Save Product A.
  2. Throw a `RuntimeException`.
  3. Save Product B.
- **Test:** Mark method `@Transactional`. Call it. Check Database.
- **Result:** Should be empty (Atomicity).

---

### **SESSION 8 LABS: OPS**

**Lab 8.1 (Actuator):**

- **Task:** Add `spring-boot-starter-actuator`.
- **Action:** Enable all endpoints in `application.yml` (`management.endpoints.web.exposure.include=*`).
- **Verify:** Access `/actuator/health`, `/actuator/beans`, `/actuator/env`. Explore the internal state of your app.

**Lab 8.2 (Profiles):**

- **Task:** Create `application-dev.yml` (server.port=8080) and `application-prod.yml` (server.port=9090).
- **Action:** Run the jar with `-Dspring.profiles.active=prod`.
- **Result:** Verify the app starts on port 9090.
